# MongoDB

### MongoDB vs RDMBS 용어 차이

| MongoDB | RDBMS |
| --- | --- |
| 데이터베이스 | 데이터베이스 |
| 컬렉션 | 테이블 |
| 도큐먼트 | 레코드 |
| 필드 | 컬럼 |
| 인덱스 | 인덱스 |
| 쿼리 결과로 커서를 반환 | 쿼리 결과로 레코드를 반환 |

### RDBMS와 큰 차이점

1. 커서를 반환 (RDBMS는 레코드를 반환)
    
    쿼리의 결과를 클라이언트 서버의 메모리에 담아두지 않아도 된다.
    
    > 커서란?
    커서는 쿼리 결과에 대한 포인터, 즉 데이터의 위치 정보가 들어가 있다.
    > 
    
    https://www.mongodb.com/ko-kr/docs/manual/reference/method/js-cursor/
    
2. 스키마 프리
    
    테이블 컬럼 수준의 스키마 프리를 지원한다. 사용할 컬럼을 미리 지정하지 않고 언제든지 필요한 시점에 데이터를 저장할 수 있다. 하지만 빠른 검색 속도를 위해 보조 인덱스를 설정한 경우 인덱스를 먼저 생성하여야하므로 해당 컬럼은 미리 정의되어 있어야 한다.
    
3. SQL 문법을 지원하지 않고 자바스크립트 기반의 명령를 이용한다.

### MongoDB의 스토리지 엔진

- MMAPv1
- WiredTiger
- In-Memory
- RocksDB
- TokuDB

### MMAPv1 엔진

MongoDB의 초창기부터 3.0 버전까지 주로 사용되던 스토리지 엔진

2.6 버전까지 데이터베이스 단위로 락을 걸어서 동시 처리 능력이 매우 떨어졌음. 3.0 버전으로 올리면서 컬렉션(테이블) 수준으로 개선되었지만 이 또한 동시성 처리에 많은 걸림돌이 된다.

내장 캐시가 없다. 운영체재 수준의 캐시를 사용하는데, 이는 큰 오버헤드를 발생시킨다.

### 설정

```yaml
storage:
	dpPath:
	indexBuildRetry:
	repariPath:
	directoryPerDB: //데이터베이스별로관리할지말지
	syncPeriodSecs: 
journal:
	enabled:
	commitIntervalMs:
engine:
mmapv1:
	preallocDataFiles:
	nsSizer:
	quota:
		enforced:
		maxFilesPerDB:
	smallFiles:
	
```

### 데이터 파일 구조

MMAPv1 스토리지 엔진을 사용하는 경우 데이터 파일은 데이터베이스 단위로 생성된다.

이때 컬렉션의 데이터는 하나의 데이터베이스 파일에만 저장되는게 아니라 데이터의 크기에 따라서 여러 개의 데이터 파일로 나뉘어서 저장된다. 파일 이름은 데이터베이스 이름이고, 자동으로 증가하는 순번을 확장자로 가진다. 최초 파일은 64MD 크기로 생성되어 점차 배수로 증가하고 2GB까지 증가하면 그 이후로는 고정된다.

이러한 구조의 경우, 컬렉션의 데이터는 적은데 데이터베이스만 많은 경우 비효율적으로 저장공간을 사용하게 된다. smallFiles 옵션으로 파일 크기를 작게 할 수 있으나, 이 옵션을 운영에서 사용하게 되면 파일이 너무 많아져서 개발서버에서만 사용하는 걸 권장한다.

.ns 파일은 데이터베이스, 컬렉션, 인덱스 정보를 저장하고 있다.

### MongoDB 서버 상태 확인

mongostat이라는 도구를 통해 몽고비디 상태를 확인할 수 있다.

### 운영체재 캐시

MMAPv1 스토리지 엔진은 내장 캐시 기능이 없다. 또한 더티 페이지(DML 문장들에 의해 데이터가 변경된 블록 또는 페이지) 를 효율적으로 관리하는 기능이 없다.

그래서 운영체제가 제공하는 페이지 캐시 기능을 사용하는데,  그로 인해 운영체제가 자체적으로 메모리를 비우는 경우 대량의 캐시된 데이터가 삭제되어 데이터 베이스에 부하가 오는 현상이 발생한다.

리눅스에서는 페이지 캐시 데이터를 읽을 때 주변의 일부 페이지를 같이 읽어들이는 경우가 있다. 이를 Read Ahead 알고리즘이라고 한다.

### 페이지 캐시 쓰기

몽고디비는 변경된 내용을 바로 데이터베이스에 저장하는 것이 아니라 리눅스 캐시로 저장하고 있다가 한번에 저장한다. 중간에 서버가 내려간 경우 WAL로그를 별도로 기록하여 손실된 데이터를 복구한다.

더티페이지를 많이 모아서 배치로 수행해야 성능상 이점을 가져올 수 있다. 그러나 너무 많이 가지고 있으면, 데이터 손실이나 복구에 너무 오랜 시간이 걸릴 수 있는 트레이드 오프가 있다. 따라서 리눅스 커널의 옵션으로 이러한 데이터 동기화를 조정할 수 있다.

### 데이터 파일 프레그먼테이션

데이터가 삭제된 경우 해당 빈 부분을 남겨두고 나중에 해당 위치에 데이터를 다시 넣는다. 그런데 작은  데이터가 삭제되는 경우, 큰 데이터를 해당 위치에 넣을 수가 없어서 데이터 공간 사용이 비효율적이게 된다., 이를 프레그멘테이션이라고 한다. 이러한 현상이 발생하는 경우 컴팩트 명령어나, 덤프후 다시 적재하여 처리할 수 있다.
